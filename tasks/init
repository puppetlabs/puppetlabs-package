#!/opt/puppetlabs/puppet/bin/ruby

require 'puppet'
require 'puppet/face'


def conflict_error(resource)
  { kind: 'puppetlabs.package/resource-conflict',
    msg: "Action may conflict with a puppet managed resource '#{resource.ref}'. Run with override to ignore",
    details: { resource: resource.ref }
  }
end

# This approach will allow us to do more complex checks for conflict.
# For example an upgrade doesn't actually  conflict with ensure = present
# That may be too complex for v1
def check_catalog(resource, action)
  Puppet::Resource::Catalog.indirection.terminus_class = :json
  Puppet.initialize_settings

  catalog = Puppet::Face[:catalog, '0.0.1'].find(Puppet[:certname])

  if catalog_resource = catalog.resources.find { |r| r.ref == resource.ref }

    ens = catalog_resource.parameters[:ensure]
    if ['latest', 'present'].include?(ens) && ['install', 'upgrade'].include?(action)
      return
    end
    if ens == 'absent' && action == 'uninstall'
      return
    end

    return conflict_error(resource)
  end
end


def check_report(resource)
  Puppet.initialize_settings
  glob = File.join(Puppet[:reportdir], Puppet[:certname], '*.yaml')

  report_path = Dir.glob(glob).max_by {|f| File.mtime(f)}
  report = File.open(report_path) {|f| YAML.load(f.read())}
  if report.resource_statuses.include?(resource.ref)
    conflict_error(resource)
  end
end


def install(provider, _version)
  if [:absent, :purged].include?(provider.properties[:ensure])
    provider.install
    provider.flush
    { status: 'installed', version: provider.properties[:ensure] }
  else
    { status: 'present', version: provider.properties[:ensure] }
  end
end

def status(provider, _version)
  version = provider.properties[:ensure]
  latest = provider.latest
  if [:absent, :purged].include?(version)
    { status: 'absent', latest: latest }
  elsif version != latest
    { status: 'out of date', version: version, latest: latest }
  else
    { status: 'up to date', version: version }
  end
end

def uninstall(provider, _version)
  if [:absent, :purged].include?(provider.properties[:ensure])
    { status: 'absent' }
  else
    provider.uninstall
    provider.flush
    { status: 'uninstalled' }
  end
end

def upgrade(provider, version)
  old_version = provider.properties[:ensure]
  provider.resource[:ensure] = version unless version.nil?
  provider.update
  provider.flush
  { old_version: old_version, version: provider.properties[:ensure] }
end

params = JSON.parse(STDIN.read)
package = params['package']
provider = params['provider']
action = params['action']
version = params['version']
override = params['override']

opts = { name: package }
opts[:provider] = provider if provider

begin
  resource = Puppet::Type.type(:package).new(opts)
  provider = resource.provider

  unless override or action == 'status'
    if error = check_report(resource)
      puts error.to_json
      exit 2
    end
  end

  result = send(action, provider, version)
  puts result.to_json
  exit 0
rescue Puppet::Error => e
  puts({ status: 'failure', _error: {kind: 'puppet.error', msg: e.message }}.to_json)
  exit 1
end
